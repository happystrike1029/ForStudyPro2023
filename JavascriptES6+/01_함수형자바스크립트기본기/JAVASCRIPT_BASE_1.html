<script>const log = console.log;</script>

# 평가
- 코드가 계산(Evaluation) 되어 값을 만드는 것

1
output >> 1 
2 + 3
output >> 5 
(2 + 3) + 4 
output >> 9 // (2 + 3) 이 먼저 5로 평가가 되고 +4가 되어 9로 평가가 된다. 
[1, 2 + 3]
output >> [1, 5] // 2 + 3 이 먼저 5로 평가가 되고 [1, 5]라는 배열로 평가가 된다. 

# 일급
- 값으로 다룰 수 있다.
- 변수에 담을 수 있다.
- 함수의 인자로 사용될 수 있다.
- 함수의 결과로 사용될 수 있다.

<script>
  const a = 10; // a라는 변수에 담을 수 있고 10이라는 값으로 다룰 수 있다. 
  const add10 = a => a + 10; // add10에 인자로 a가 전달 될 수 있다. 
  const r = add10(a); // 함수의 리턴값(결과)으로 사용될 수 있다. 
  // log(r);
</script>

# 일급 함수
- 함수를 값으로 다룰 수 있다.
- 조합성과 추상화의 도구

<script>
  const add5 = a => a + 5; // 변수에 함수를 값으로 담아 다룰 수 있다는 뜻 
  log(add5); 
  // add5를 값으로 다뤄서 함수(log)에 전달하면 출력이 된다 
  // output >> a => a + 5;
  log(add5(5));
  // 함수는 평가에서 (5+5) 값으로 만들 수 있다. (10) 또 다른 함수에 전달 가능(log)
  // output >> 10 

  const f1 = () => () => 1;
  // 함수가 일급이라는 것은 함수의 결과값으로 함수가 사용이 가능하다는 뜻 
  log(f1());
  // 변수(f1()) 함수(log)에 출력시 함수(()=>1)가 출력된다. 
  // 즉 함수의 결과가 함수인 형태 
  // output >> () => 1

  const f2 = f1();
  // 함수는 다시 또 다른 변수에 담을 수 있게 된다. 
  log(f2);
  // 어떤식으로 나올까?
  // 결과값으로 위와 같이 동일하게 함수가 출력된다.
  // output >> () => 1
  log(f2());
  // 어떤식으로 나올까?
  // 담겨진 함수를 내가 원하는 시점에 평가해서 결과를 만들 수 있다. 
  // output >> 1

  // 함수형 프로그래밍에서는 함수가 일급이라는 성질을 사용하여 많은 조합을 만들어내고 추상화의 도구로 사용 가능하다는 뜻 
</script>

# 일급 함수
- 함수가 값으로 다뤄질 수 있다.

# 고차 함수
- 함수를 값으로 다루는 함수

# 고차 함수의 2가지 케이스 
## 함수를 인자로 받아서 실행하는 함수
- apply1
- times

<script>
  const apply1 = f => f(1);
  // 함수(f)를 받아서 함수에 1을 적용하는 함수이다. 
  // 즉 함수가 함수를 받아서 실행하는 것 
  const add2 = a => a + 2;
  log(apply1(add2));
  // aplly1 에서는 a => a + 2 함수를 받아서 이 함수 안에서 실행해주고 있다. 
  // 3으로 평가되고 있다. 
  log(apply1(a => a - 1));
  // 다음과 같은 함수를 적용했을때의 값은 ? 
  // 0으로 평가되고 있다.  
  const times = (f, n) => {
    let i = -1;
    while (++i < n) f(i);
  };
  // times는 f라는 함수와 n이라는 숫자를 인자값으로 받는 함수 
  // n이라는 숫자만큼 f라는 함수를 실행하는 형태 

  times(log, 3);
  // 3번 실행하며 로그를 출력 

  times(a => log(a + 10), 3);
  // 위와 같은 형태를 어플리케이티브 프로그래밍이라고도 한다. 
</script>

## 함수를 만들어 리턴하는 함수 (클로저를 만들어 리턴하는 함수)
- addMaker

<script>
  const addMaker = a => b => a + b;
  const addResult = addMaker(10);
  log(addResult);
  // 이런 경우에는 어떤식으로 나올까? 
  // output >> b => a + b 
  log(addResult(5));
  // output >> 15
  log(addResult(10));
  // output >> 20 

  // addMaker는 함수(클로저)를 만들어 리턴하는 함수 
  // 클로저 ?  
  // b => a + b 해당 함수가 앞에 있는 a를 계속 기억하고 있다는 뜻 
  // b => a + b 는 함수이자 a를 기억하는 클로저이다. 
  // 즉 클로저란 b => a + b 함수가 만들어질때 환경인 a와 함수 자체의 객체(b => a + b) 를 통칭해서 말하는 용어
</script>
