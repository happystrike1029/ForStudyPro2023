
<html>
    <head>

</head>
    <body>
        <div id="drawLog"></div>
        <script>
    
            const log = console.log;
            const drawLog = [];
        
            const products = [
            {name: "반팔티", price:15000},
            {name: "긴팔티", price:20000},
            {name: "핸드폰케이스", price:17000},
            {name: "후드티", price:30000}
            ]
        
            drawLog.push(products);
        
            let prices = [];
            for(const p of products){
                prices.push(p.name);
            }
            log(prices);
            drawLog.push(prices);
            // 해당 부분을 조금 더 쉽게 변환하고자 하면 map 이라는 함수를 통해 변환이 가능하다. 
        
            const map =(f, iter)=>{
                let res = [];
                for(const p of iter){
                    res.push(f(p));
                }
                // log(names); 직접적인 변화를 일으키는 함수나 메서드에 보내는 것이 아닌 본인의 return 값으로 처리 
                // return 된 값을 변화를 일으키기 위해 사용할 수 있음 
                // iter라고 한 이유? 맵 함수가 받는 값이 이터러블 프로토콜을 따른다. 
                // f는? 함수를 줘서 어떤 값을 주게 될지 정해준다. 
                return res;  
            }
            
            log([1, 2, 3].map(a => a+1)); 
            drawLog.push([1, 2, 3].map(a => a+1));
            
            var test = document.querySelectorAll('*'); 
            log(test); 
            drawLog.push(test);
            // log(test.map(el => el.nodeName)); 
            // array를 상속받은 객체가 아니기 때문에 해당 부분은 출력되지 않는다. 
            log(map(el => el.nodeName, document.querySelectorAll('*'))); 
            drawLog.push(map(el => el.nodeName, document.querySelectorAll('*')));
            // 하지만 만든 map 함수에서는 출력이 가능하다. 
            
            const it  = document.querySelectorAll('*')[Symbol.iterator](); 
            log(it.next()); // {"value": {html},"done": false}
            
            function *gen(){
                yield 2;
                if (false) yield 3;
                yield 4;
            }
            
            log(map(a => a*a, gen())); 
            drawLog.push(map(a => a*a, gen()));
            // generator 의 함수들도 map이 가능하다. 
            // 브라우저 헬퍼 스크립트들이 이터러블 프로토콜을 따르고 있기 때문에 
            // 많은 헬퍼 함수들과의 조합성이 좋아진다는 뜻 
            // 유연하고 다형성이 높은 편에 속함 
            
            let m = new Map(); 
            m.set('a', 10); 
            m.set('b', 10); 
            
            const it2 = m[Symbol.iterator]();
            log(it2.next()); 
            log(it2.next()); 
            log(it2.next()); 
            
            // map(([k, a]=>[k, a*2], m)); 
            log(new Map(map(([k, a]) => [k, a * 2], m)));
            drawLog.push(new Map(map(([k, a]) => [k, a * 2], m)));
              
            // filter : 걸러내는 함수 
            let under20000 = [];
            for (const p of products){
                if(p.price < 20000) under20000.push(p);
            }
            log(...under20000);
            
            const filter = (f, iter) => {
                let res = [];
                for (const a of iter) {
                if (f(a)) res.push(a);
                }
                return res;
            };

            log(...filter(p=>p.price <20000, products)); 

            log(filter(n => n %2, [1, 2, 3, 4])); 

            log(filter(n => n%2, function *(){
                yield 1; 
                yield 2; 
                yield 3; 
                yield 4; 
                yield 5; 
                yield 6; 
            }()));
        // reduce 
        /* 바닐라 JS */
        const array1 = [1, 2, 3, 4, 5];
        // 0 + 1 + 2 + 3 + 4
        const initialValue = 0;
        const sumWithInitial = array1.reduce(
            (accumulator, currentValue) => accumulator + currentValue,
            initialValue
        );

        console.log("Vanilla JS : ", sumWithInitial);

        // Expected output: 10
        // 배열.reduce((누적값, 현잿값, 인덱스, 요소) => { return 결과 }, 초깃값);
        // reduce 라는 개념 조금 더 익히기 

        const promiseFactory = (time) => {
        return new Promise((resolve, reject) => {
            console.log(time); 
            setTimeout(resolve, time);
        });
        };

        [1000, 2000, 3000, 4000].reduce((acc, cur) => {
        return acc.then(() => promiseFactory(cur));
        }, Promise.resolve());

        /* 예제 JS */
        const nums = [1, 2, 3, 4, 5];
        let total = 0; 
        for(const n of nums){
            total = total + n; 
        }
        log("직접 더한 : ", total); 
        // 해당 부분을 조금 더 쉽게 처리하는 법 
        const reduce = (f, acc, iter) =>{
            for(const a of iter){
                acc = f(acc, a);
            }
            return acc; 
        };

        const add = (a, b) => a+b; 
        log("reduce 함수 사용 : ", reduce(add, 0, [1, 2, 3, 4, 5])); 
        log("add 연속 사용 : ", add(add(add(add(add(0,1),2),3),4),5));

        const reduce2 = (f, acc, iter) =>{
            if(!iter){
                iter = acc[Symbol.iterator]();
                acc = iter.next().value; 
            }
            for(const a of iter){
                acc = f(acc, a);
            }
            return acc; 
        }
        log("reduce 부분 수정 함수 사용 : ", reduce2(add, [1, 2, 3, 4, 5])); 

        let drawHtml = '';
        for(let i of drawLog){
        drawHtml += `<p>${i.toString()}</p>`
        // drawHtml += `<p>${JSON.stringify(i.toString())}</p>`
        }
        log(drawHtml);
        document.getElementById("drawLog").innerHTML = drawHtml;
        // >> 해당 부분 계속 에러가 났었는데 이유는 script와 html 읽는 부분의 위치가 달라지기 때문 
        // 즉 실제화면에서는 페이지가 구현되기 이전이므로 body 태그의 내용이 나오기도 전인데 관련 id 태그를 찾고 있으니 당연히 찾지 못한다는 에러 메시지를 띄우는 것 
        
        
        </script>
    </body>
</html> 